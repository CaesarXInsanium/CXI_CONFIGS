import"regenerator-runtime";import BrowserGuard from"../../modules/browser_guard";import Whitelist from"../../modules/whitelist";import*as chromePromise from"../../modules/utils/chrome_promise";jest.mock("../../modules/whitelist");const whitelist=new Whitelist;const windowWhitelist=new Whitelist;const tabWhitelist=new Whitelist;const whitelists={whitelist:whitelist,windowWhitelist:windowWhitelist,tabWhitelist:tabWhitelist};const defaultUserPlatform={isMacUser:true,isWindowsUser:false};const userDisplayBounds={height:1440,left:0,top:0,width:3440};const translations={browserguard:{site_not_permitted:"You are not permitted to access that site.",click_outside:"You are not permitted to click outside of the exam window."}};describe("BrowserGuard",(()=>{beforeEach((()=>{jest.clearAllMocks();console.error=jest.fn();chrome.system.display={getInfo:jest.fn()};chrome.tabs.onUpdated.addListener=jest.fn();chrome.tabs.onUpdated.removeListener=jest.fn();chrome.windows.getAll=jest.fn();chrome.windows.update=jest.fn();chrome.windows.onBoundsChanged={addListener:jest.fn(),removeListener:jest.fn()};chrome.windows.onFocusChanged.addListener=jest.fn();chrome.windows.onFocusChanged.removeListener=jest.fn()}));describe("constructor",(()=>{it("will generate an error if constructed without all required whitelist instances",(()=>{new BrowserGuard({exam:whitelist,window:windowWhitelist},defaultUserPlatform);expect(console.error).toHaveBeenCalledWith("ERROR: Browser Guard is missing required class instantiations.")}))}));describe("start",(()=>{it("will enable browser guard if guard is currently disabled",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);jest.spyOn(browserGuard,"_setupChromeEventListeners").mockImplementation((()=>"Setting up Chrome event listeners"));jest.spyOn(browserGuard,"_sendMessageBrowserGuardActive").mockImplementation((()=>"Browser Guard Active"));browserGuard.start(1,translations);expect(browserGuard._isActive).toBeTruthy();expect(browserGuard._setupChromeEventListeners).toHaveBeenCalled();expect(browserGuard._sendMessageBrowserGuardActive).toHaveBeenCalled()}));it("will not enable browser guard if guard is currently enabled",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);jest.spyOn(browserGuard,"_setupChromeEventListeners").mockImplementation((()=>"Setting up Chrome event listeners"));jest.spyOn(browserGuard,"_sendMessageBrowserGuardActive").mockImplementation((()=>"Browser Guard Active"));browserGuard.start(1,translations);browserGuard.start(1,translations);expect(browserGuard._isActive).toBeTruthy();expect(browserGuard._setupChromeEventListeners).toHaveBeenCalledTimes(1);expect(browserGuard._sendMessageBrowserGuardActive).toHaveBeenCalledTimes(1)}))}));describe("stop",(()=>{it("will disable browser guard",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);jest.spyOn(browserGuard,"_stopFullscreen").mockImplementation((()=>"Disabling Forced Fullscreen"));jest.spyOn(browserGuard,"_detachChromeEventListeners").mockImplementation((()=>"Detaching Chrome event listeners"));jest.spyOn(browserGuard,"_sendMessageBrowserGuardDisabled").mockImplementation((()=>"Browser Guard Disabled"));browserGuard.start(1,translations);browserGuard.stop();expect(browserGuard._isActive).toBeFalsy();expect(browserGuard._stopFullscreen).toHaveBeenCalled();expect(browserGuard._detachChromeEventListeners).toHaveBeenCalled();expect(browserGuard._sendMessageBrowserGuardDisabled).toHaveBeenCalled()}))}));describe("enableBlockNewTabs",(()=>{it("will enable blocking of new tabs if block new tabs is currently disabled and browser guard is active",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);browserGuard.start(1,translations);browserGuard.enableBlockNewTabs();expect(browserGuard._examWhitelist.enable).toHaveBeenCalled();expect(browserGuard._windowWhitelist.enable).toHaveBeenCalled();expect(browserGuard._tabWhitelist.enable).toHaveBeenCalled();expect(chrome.tabs.query).toHaveBeenCalled();expect(chrome.tabs.onUpdated.addListener).toHaveBeenCalled();expect(browserGuard._isBlockNewTabsActive).toBeTruthy()}));it("will enable blocking of new tabs if block new tabs is currently disabled and browser guard is disabled",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);browserGuard.enableBlockNewTabs();expect(browserGuard._examWhitelist.enable).toHaveBeenCalled();expect(browserGuard._windowWhitelist.enable).toHaveBeenCalled();expect(browserGuard._tabWhitelist.enable).toHaveBeenCalled();expect(chrome.tabs.query).toHaveBeenCalled();expect(chrome.tabs.onUpdated.addListener).toHaveBeenCalled();expect(browserGuard._isBlockNewTabsActive).toBeTruthy()}));it("will not re-enable blocking of new tabs if block new tabs is currently active",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);browserGuard.enableBlockNewTabs();browserGuard.enableBlockNewTabs();expect(browserGuard._examWhitelist.enable).toHaveBeenCalledTimes(1);expect(browserGuard._windowWhitelist.enable).toHaveBeenCalledTimes(1);expect(browserGuard._tabWhitelist.enable).toHaveBeenCalledTimes(1);expect(chrome.tabs.query).toHaveBeenCalledTimes(1);expect(chrome.tabs.onUpdated.addListener).toHaveBeenCalledTimes(1);expect(browserGuard._isBlockNewTabsActive).toBeTruthy()}))}));describe("disableBlockNewTabs",(()=>{it("will disable block of new tabs",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);browserGuard.enableBlockNewTabs();browserGuard.disableBlockNewTabs();expect(browserGuard._examWhitelist.disable).toHaveBeenCalled();expect(browserGuard._windowWhitelist.disable).toHaveBeenCalled();expect(browserGuard._tabWhitelist.disable).toHaveBeenCalled();expect(chrome.tabs.onUpdated.removeListener).toHaveBeenCalled();expect(browserGuard._isBlockNewTabsActive).toBeFalsy()}))}));describe("enableFullscreen",(()=>{it("will generate an error if input values not provided when setting fullscreen active",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);browserGuard.start(1,translations);browserGuard.fullscreen.start({examTabId:null,windowId:null,cameraTabId:null});expect(console.error).toHaveBeenCalled();expect(browserGuard.fullscreen.isActive).toBeFalsy()}));it("will not enable fullscreen if browser guard is not active",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const examTabId=1;const windowId=2;const cameraTabId=3;chromePromise.storageLocalGet=jest.fn((()=>false));browserGuard.fullscreen.start({examTabId:examTabId,windowId:windowId,cameraTabId:cameraTabId});expect(chromePromise.storageLocalGet).not.toHaveBeenCalled();expect(browserGuard.fullscreen.isActive).toBeFalsy()}));it("will not enable fullscreen if fullscreen override is set in local storage",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const examTabId=1;const windowId=2;const cameraTabId=3;browserGuard.user.displayBounds=userDisplayBounds;chromePromise.storageLocalGet=jest.fn((()=>({fullscreen_override:"1"})));jest.spyOn(browserGuard,"_setExamWindowStateFullscreen").mockImplementation((()=>"Setting exam window state to fullscreen."));jest.spyOn(browserGuard,"_startForceFocus").mockImplementation((()=>"Enabling force focus."));browserGuard.start(1,translations);await browserGuard.fullscreen.start({examTabId:examTabId,windowId:windowId,cameraTabId:cameraTabId});expect(chromePromise.storageLocalGet).toHaveBeenCalled();expect(browserGuard.fullscreen.isActive).toBeFalsy()}));it("will enable fullscreen if browser guard is active",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const examTabId=1;const windowId=2;const cameraTabId=3;const focusInterval=.5;chromePromise.storageLocalGet=jest.fn((()=>{}));chromePromise.systemDisplayGetInfo=jest.fn((()=>[{isPrimary:true,workArea:userDisplayBounds}]));jest.spyOn(browserGuard,"_setExamWindowStateFullscreen").mockImplementation((()=>"Setting exam window state to fullscreen."));jest.spyOn(browserGuard,"_startForceFocus").mockImplementation((()=>"Enabling force focus."));browserGuard.start(1,translations);await browserGuard.fullscreen.start({examTabId:examTabId,windowId:windowId,cameraTabId:cameraTabId});expect(chromePromise.storageLocalGet).toHaveBeenCalled();expect(chromePromise.systemDisplayGetInfo).toHaveBeenCalled();expect(browserGuard.forceFocus.windowState).toBe("normal");expect(browserGuard.user.examTabId).toBe(examTabId);expect(browserGuard.user.focusedWindowId).toBe(windowId);expect(browserGuard.user.displayBounds).toBe(userDisplayBounds);expect(browserGuard._setExamWindowStateFullscreen).toHaveBeenCalledWith(windowId);expect(browserGuard._startForceFocus).toHaveBeenCalledWith(cameraTabId,focusInterval);expect(browserGuard.fullscreen.isActive).toBeTruthy()}));it("will not re-enable fullscreen if fullscreen is currently active",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);chromePromise.storageLocalGet=jest.fn((()=>{}));chromePromise.systemDisplayGetInfo=jest.fn((()=>[{isPrimary:true,workArea:userDisplayBounds}]));jest.spyOn(browserGuard,"_setExamWindowStateFullscreen").mockImplementation((()=>"Setting exam window state to fullscreen."));jest.spyOn(browserGuard,"_startForceFocus").mockImplementation((()=>"Enabling force focus."));browserGuard.start(1,translations);await browserGuard.fullscreen.start({examTabId:1,windowId:2,cameraTabId:3});await browserGuard.fullscreen.start({examTabId:4,windowId:5,cameraTabId:6});expect(chromePromise.storageLocalGet).toHaveBeenCalledTimes(1);expect(chromePromise.systemDisplayGetInfo).toHaveBeenCalledTimes(1);expect(browserGuard._setExamWindowStateFullscreen).toHaveBeenCalledTimes(1);expect(browserGuard._startForceFocus).toHaveBeenCalledTimes(1);expect(browserGuard.fullscreen.isActive).toBeTruthy()}))}));describe("disableFullscreen",(()=>{it("will disable fullscreen",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const examTabId=1;const windowId=2;const cameraTabId=3;const cameraWindowId=4;browserGuard.user.displayBounds=userDisplayBounds;chromePromise.storageLocalGet=jest.fn((()=>{}));chromePromise.windowsGetAll=jest.fn((()=>[{id:1},{id:2},{id:3}]));jest.spyOn(browserGuard,"_setExamWindowStateFullscreen").mockImplementation((()=>"Setting exam window state to fullscreen."));jest.spyOn(browserGuard,"_startForceFocus").mockImplementation((()=>"Enabling force focus."));jest.spyOn(browserGuard,"_stopForceFocus").mockImplementation((()=>"Disabling force focus."));browserGuard.start(1,translations);await browserGuard.fullscreen.start(examTabId,windowId,cameraTabId,cameraWindowId);await browserGuard.fullscreen.stop();expect(chromePromise.windowsGetAll).toBeCalled();expect(chrome.windows.update).toBeCalledTimes(3);expect(browserGuard._stopForceFocus).toBeCalled();expect(browserGuard.fullscreen.isActive).toBeFalsy()}))}));describe("forceBrowserFocus",(()=>{it("will manually focus browser window",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const windowId=1;const tabId=2;chromePromise.windowsUpdate=jest.fn();await browserGuard.forceBrowserFocus(windowId,tabId);expect(chromePromise.windowsUpdate).toBeCalledWith(windowId,{state:"normal",focused:true});expect(chrome.tabs.update).toBeCalledWith(tabId,{active:true})}))}));describe("_startForceFocus",(()=>{it("will generate an error if required input values missing when activating force focus",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);browserGuard.forceFocus.start(null);expect(console.error).toHaveBeenCalled();expect(chrome.windows.onBoundsChanged.addListener).not.toBeCalled();expect(chrome.windows.onFocusChanged.addListener).not.toBeCalled();expect(browserGuard.forceFocus.getCurrentWindowInterval).toBeNull();expect(browserGuard.forceFocus.isActive).toBeFalsy()}));it("will not enable force focus if browser guard is not active",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const cameraTabId=1;browserGuard.forceFocus.start(cameraTabId,translations);expect(chrome.windows.onBoundsChanged.addListener).not.toBeCalled();expect(chrome.windows.onFocusChanged.addListener).not.toBeCalled();expect(browserGuard.forceFocus.getCurrentWindowInterval).toBeNull();expect(browserGuard.forceFocus.isActive).toBeFalsy()}));it("will enable force focus",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const cameraTabId=1;jest.spyOn(browserGuard,"_windowOnBoundsChangedHandler").mockImplementation((()=>"Handling onBoundsChanged event."));jest.spyOn(browserGuard,"_onFocusedChangedHandler").mockImplementation((()=>"Handling onFocusChanged event."));browserGuard.start(1,translations);browserGuard.forceFocus.start(cameraTabId);expect(chrome.windows.onBoundsChanged.addListener).toBeCalledWith(browserGuard._windowOnBoundsChangedHandler);expect(chrome.windows.onFocusChanged.addListener).toBeCalledWith(browserGuard._onFocusedChangedHandler);expect(browserGuard.forceFocus.getCurrentWindowInterval).not.toBeUndefined();expect(browserGuard.forceFocus.isActive).toBeTruthy()}));it("will not re-enable force focus if force focus is currently active",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const cameraTabId=1;browserGuard.start(1,translations);browserGuard.forceFocus.start(cameraTabId);browserGuard.forceFocus.start(cameraTabId);expect(chrome.windows.onBoundsChanged.addListener).toBeCalledTimes(1);expect(chrome.windows.onFocusChanged.addListener).toBeCalledTimes(1);expect(browserGuard.forceFocus.getCurrentWindowInterval).not.toBeUndefined();expect(browserGuard.forceFocus.isActive).toBeTruthy()}));it("will trigger getCurrentWindowIntervalHandler every 0.5 seconds after force focus is enabled",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const cameraTabId=1;const focusInterval=.5;jest.useFakeTimers();jest.spyOn(browserGuard,"_getCurrentWindowIntervalHandler").mockImplementation((()=>"Checking current window."));browserGuard.start(1,translations);browserGuard.forceFocus.start(cameraTabId,focusInterval);expect(browserGuard._getCurrentWindowIntervalHandler).not.toBeCalled();jest.advanceTimersByTime(500);expect(browserGuard._getCurrentWindowIntervalHandler).toBeCalled();expect(browserGuard._getCurrentWindowIntervalHandler).toHaveBeenCalledTimes(1);jest.advanceTimersByTime(500);expect(browserGuard._getCurrentWindowIntervalHandler).toHaveBeenCalledTimes(2)}));it("will not set onFocusChanged listener if user platform is not a Mac User when enabling force focus",(()=>{const browserGuard=new BrowserGuard(whitelists,{isMacUser:false,isWindowsUser:true});const cameraTabId=1;const cameraWindowId=2;browserGuard.start(1,translations);browserGuard.forceFocus.start(cameraTabId,cameraWindowId);expect(chrome.windows.onFocusChanged.addListener).not.toBeCalled()}))}));describe("_stopForceFocus",(()=>{it("will disable force focus",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const cameraTabId=1;const cameraWindowId=2;jest.useFakeTimers();jest.spyOn(browserGuard,"_windowOnBoundsChangedHandler").mockImplementation((()=>"Handling onBoundsChanged event."));jest.spyOn(browserGuard,"_onFocusedChangedHandler").mockImplementation((()=>"Handling onFocusChanged event."));jest.spyOn(browserGuard,"_getCurrentWindowIntervalHandler").mockImplementation((()=>"Checking current window."));browserGuard.start(1,translations);browserGuard.forceFocus.start(cameraTabId,cameraWindowId);browserGuard.forceFocus.stop();expect(chrome.windows.onBoundsChanged.removeListener).toBeCalledWith(browserGuard._windowOnBoundsChangedHandler);expect(chrome.windows.onFocusChanged.removeListener).toBeCalledWith(browserGuard._onFocusedChangedHandler);expect(browserGuard.forceFocus.isActive).toBeFalsy();expect(browserGuard._getCurrentWindowIntervalHandler).not.toHaveBeenCalled();jest.advanceTimersByTime(500);expect(browserGuard._getCurrentWindowIntervalHandler).not.toHaveBeenCalled()}))}));describe("_closeTabOnUpdatedHandler",(()=>{it("will not close tab when onUpdated event is triggered if change status is not loading",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const changeInfoStatus="complete";const tabId=1;const tabUrl="https://example.com/";browserGuard.enableBlockNewTabs();browserGuard._closeTabOnUpdatedHandler(tabId,{status:changeInfoStatus},{id:tabId,url:tabUrl});expect(chrome.tabs.remove).not.toBeCalled()}));it("will not close tab when onUpdated event is triggered if tab url belongs to examWhiteList",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const changeInfoStatus="loading";const tabId=1;const tabUrl="https://example.com/";browserGuard._examWhitelist.isAllowed=jest.fn((()=>true));browserGuard.enableBlockNewTabs();browserGuard._closeTabOnUpdatedHandler(tabId,{status:changeInfoStatus},{id:tabId,url:tabUrl});expect(chrome.tabs.remove).not.toBeCalled()}));it("will not close tab when onUpdated event is triggered if tab url belongs to tabWhitelist",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const changeInfoStatus="loading";const tabId=1;const tabUrl="https://example.com/";browserGuard._tabWhitelist.isAllowed=jest.fn((()=>true));browserGuard.enableBlockNewTabs();browserGuard._closeTabOnUpdatedHandler(tabId,{status:changeInfoStatus},{id:tabId,url:tabUrl});expect(chrome.tabs.remove).not.toBeCalled()}));it("will close tab when onUpdated event is triggered if tab is not loading and does not belong to any whitelist",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const changeInfoStatus="loading";const tabId=1;const tabUrl="https://example.com/";browserGuard._examWhitelist.isAllowed=jest.fn((()=>false));browserGuard._tabWhitelist.isAllowed=jest.fn((()=>false));jest.spyOn(browserGuard,"_sendAlertToTabs").mockImplementation((()=>"Sending message to tabs."));browserGuard._translations=translations;browserGuard.enableBlockNewTabs();browserGuard._closeTabOnUpdatedHandler(tabId,{status:changeInfoStatus},{id:tabId,url:tabUrl});expect(chrome.tabs.remove).toBeCalledWith(tabId);expect(browserGuard._sendAlertToTabs).toBeCalledWith("You are not permitted to access that site.")}))}));describe("_windowOnBoundsChangedHandler",(()=>{it("will not log a focus loss and set exam window to fullscreen when onBoundsChangedHandler event is passed window id that is not equal to focused browser id",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const windowChanged={id:1};jest.spyOn(browserGuard,"_logFocusLost").mockImplementation((()=>"Logging focus lost."));jest.spyOn(browserGuard,"_setExamWindowStateFullscreen").mockImplementation((()=>"Setting exam window state to fullscreen."));browserGuard.user.focusedWindowId=2;browserGuard._windowOnBoundsChangedHandler(windowChanged);expect(browserGuard._logFocusLost).not.toBeCalled();expect(browserGuard._setExamWindowStateFullscreen).not.toBeCalled()}));it("will not log a focus loss and set exam window to fullscreen when onBoundsChangedHandler event is triggered and expected focused window is currently fullscreen",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const windowChanged={id:1};jest.spyOn(browserGuard,"_isFocusedWindowFullscreen").mockImplementation((()=>true));jest.spyOn(browserGuard,"_logFocusLost").mockImplementation((()=>"Logging focus lost."));jest.spyOn(browserGuard,"_setExamWindowStateFullscreen").mockImplementation((()=>"Setting exam window state to fullscreen."));browserGuard.user.focusedWindowId=1;browserGuard._windowOnBoundsChangedHandler(windowChanged);expect(browserGuard._logFocusLost).not.toBeCalled();expect(browserGuard._setExamWindowStateFullscreen).not.toBeCalled()}));it("will log a focus loss and set exam window to fullscreen when onBoundsChangedHandler event is triggered and expected focused window is not currently fullscreen",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const windowChanged={id:1};jest.spyOn(browserGuard,"_isFocusedWindowFullscreen").mockImplementation((()=>false));jest.spyOn(browserGuard,"_logFocusLost").mockImplementation((()=>"Logging focus lost."));jest.spyOn(browserGuard,"_setExamWindowStateFullscreen").mockImplementation((()=>"Setting exam window state to fullscreen."));browserGuard.user.focusedWindowId=1;browserGuard._windowOnBoundsChangedHandler(windowChanged);expect(browserGuard._logFocusLost).toBeCalled();expect(browserGuard._setExamWindowStateFullscreen).toBeCalled()}))}));describe("_getCurrentWindowIntervalHandler",(()=>{it("will get the current window within Chrome",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);browserGuard.user.displayBounds=userDisplayBounds;chromePromise.windowsGetCurrent=jest.fn((()=>({id:1})));jest.spyOn(browserGuard,"_checkIfFocusedWindowIsMinimized").mockImplementation((()=>false));jest.spyOn(browserGuard,"_checkIfRefocusRequired").mockImplementation((()=>"Checking if refocus is required."));await browserGuard._getCurrentWindowIntervalHandler();expect(chromePromise.windowsGetCurrent).toHaveBeenCalled()}));it("will identify if a window is whitelisted",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const currentWindowId=1;browserGuard.user.displayBounds=userDisplayBounds;chromePromise.windowsGetCurrent=jest.fn((()=>({id:currentWindowId})));browserGuard._windowWhitelist.isAllowed=jest.fn((()=>true));jest.spyOn(browserGuard,"_checkIfFocusedWindowIsMinimized").mockImplementation((()=>false));jest.spyOn(browserGuard,"_checkIfRefocusRequired").mockImplementation((()=>"Checking if refocus is required."));await browserGuard._getCurrentWindowIntervalHandler();expect(browserGuard._windowWhitelist.isAllowed).toHaveBeenCalledWith(currentWindowId,true)}));it("will check if the expected forced focus window is minimized",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const currentWindowId=1;const isWindowWhitelisted=true;browserGuard.user.displayBounds=userDisplayBounds;chromePromise.windowsGetCurrent=jest.fn((()=>({id:currentWindowId})));browserGuard._windowWhitelist.isAllowed=jest.fn((()=>isWindowWhitelisted));jest.spyOn(browserGuard,"_checkIfFocusedWindowIsMinimized").mockImplementation((()=>false));jest.spyOn(browserGuard,"_checkIfRefocusRequired").mockImplementation((()=>"Checking if refocus is required."));await browserGuard._getCurrentWindowIntervalHandler();expect(browserGuard._checkIfFocusedWindowIsMinimized).toHaveBeenCalledWith({id:currentWindowId},isWindowWhitelisted)}));it("will not check for required refocus if forced focus window is minimized",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const currentWindowId=1;const isWindowWhitelisted=true;browserGuard.user.displayBounds=userDisplayBounds;chromePromise.windowsGetCurrent=jest.fn((()=>({id:currentWindowId})));browserGuard._windowWhitelist.isAllowed=jest.fn((()=>isWindowWhitelisted));jest.spyOn(browserGuard,"_checkIfFocusedWindowIsMinimized").mockImplementation((()=>true));jest.spyOn(browserGuard,"_checkIfRefocusRequired").mockImplementation((()=>"Checking if refocus is required."));await browserGuard._getCurrentWindowIntervalHandler();expect(browserGuard._checkIfRefocusRequired).not.toHaveBeenCalled()}));it("will check for required refocus if forced focus is not minimized",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const currentWindowId=1;const isWindowWhitelisted=false;browserGuard.user.displayBounds=userDisplayBounds;chromePromise.windowsGetCurrent=jest.fn((()=>({id:currentWindowId})));browserGuard._windowWhitelist.isAllowed=jest.fn((()=>isWindowWhitelisted));jest.spyOn(browserGuard,"_checkIfFocusedWindowIsMinimized").mockImplementation((()=>false));jest.spyOn(browserGuard,"_checkIfRefocusRequired").mockImplementation((()=>"Checking if refocus is required."));await browserGuard._getCurrentWindowIntervalHandler();expect(browserGuard._checkIfRefocusRequired).toHaveBeenCalledWith({id:currentWindowId},isWindowWhitelisted)}))}));describe("_checkIfFocusedWindowIsMinimized",(()=>{it("will not check if focused window is minimized when userPlatform is Windows OS",(async()=>{const browserGuard=new BrowserGuard(whitelists,{isMacUser:false,isWindowsUser:true});const currentWindow={focused:true,id:1};const isWindowWhitelisted=true;chromePromise.windowsGet=jest.fn();jest.spyOn(browserGuard,"_isFocusedWindowFullscreen").mockImplementation((()=>false));jest.spyOn(browserGuard,"_logFocusLost").mockImplementation((()=>"Logging focus lost"));jest.spyOn(browserGuard,"_setExamWindowStateFullscreen").mockImplementation((()=>"Setting exam window state fullscreen"));const isFocusedWindowMinimized=await browserGuard._checkIfFocusedWindowIsMinimized(currentWindow,isWindowWhitelisted);expect(chromePromise.windowsGet).not.toBeCalled();expect(browserGuard._isFocusedWindowFullscreen).not.toBeCalled();expect(browserGuard._logFocusLost).not.toBeCalled();expect(browserGuard._setExamWindowStateFullscreen).not.toBeCalled();expect(isFocusedWindowMinimized).toBeFalsy()}));it("will not check if focused window is minimized when current window is not whitelisted",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const currentWindow={focused:true,id:1};const isWindowWhitelisted=false;chromePromise.windowsGet=jest.fn();jest.spyOn(browserGuard,"_isFocusedWindowFullscreen").mockImplementation((()=>false));jest.spyOn(browserGuard,"_logFocusLost").mockImplementation((()=>"Logging focus lost"));jest.spyOn(browserGuard,"_setExamWindowStateFullscreen").mockImplementation((()=>"Setting exam window state fullscreen"));const isFocusedWindowMinimized=await browserGuard._checkIfFocusedWindowIsMinimized(currentWindow,isWindowWhitelisted);expect(chromePromise.windowsGet).not.toBeCalled();expect(browserGuard._isFocusedWindowFullscreen).not.toBeCalled();expect(browserGuard._logFocusLost).not.toBeCalled();expect(browserGuard._setExamWindowStateFullscreen).not.toBeCalled();expect(isFocusedWindowMinimized).toBeFalsy()}));it("will not check if focused window is minimized when current window id is expected focused browser window id",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const currentWindow={focused:true,id:1};const isWindowWhitelisted=true;browserGuard.user.focusedWindowId=1;chromePromise.windowsGet=jest.fn();jest.spyOn(browserGuard,"_isFocusedWindowFullscreen").mockImplementation((()=>false));jest.spyOn(browserGuard,"_logFocusLost").mockImplementation((()=>"Logging focus lost"));jest.spyOn(browserGuard,"_setExamWindowStateFullscreen").mockImplementation((()=>"Setting exam window state fullscreen"));const isFocusedWindowMinimized=await browserGuard._checkIfFocusedWindowIsMinimized(currentWindow,isWindowWhitelisted);expect(chromePromise.windowsGet).not.toBeCalled();expect(browserGuard._isFocusedWindowFullscreen).not.toBeCalled();expect(browserGuard._logFocusLost).not.toBeCalled();expect(browserGuard._setExamWindowStateFullscreen).not.toBeCalled();expect(isFocusedWindowMinimized).toBeFalsy()}));it("will not check if focused window is minimized when current window is not focused",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const currentWindow={focused:false,id:2};const isWindowWhitelisted=true;browserGuard.user.focusedWindowId=1;chromePromise.windowsGet=jest.fn();jest.spyOn(browserGuard,"_isFocusedWindowFullscreen").mockImplementation((()=>false));jest.spyOn(browserGuard,"_logFocusLost").mockImplementation((()=>"Logging focus lost"));jest.spyOn(browserGuard,"_setExamWindowStateFullscreen").mockImplementation((()=>"Setting exam window state fullscreen"));const isFocusedWindowMinimized=await browserGuard._checkIfFocusedWindowIsMinimized(currentWindow,isWindowWhitelisted);expect(chromePromise.windowsGet).not.toBeCalled();expect(browserGuard._isFocusedWindowFullscreen).not.toBeCalled();expect(browserGuard._logFocusLost).not.toBeCalled();expect(browserGuard._setExamWindowStateFullscreen).not.toBeCalled();expect(isFocusedWindowMinimized).toBeFalsy()}));it("will check if focused window is minimized and will not log focus lost or set window state fullscreen when expected focused browser window is currently fullscreen",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const currentWindow={focused:true,id:2};const isWindowWhitelisted=true;browserGuard.user.focusedWindowId=1;chromePromise.windowsGet=jest.fn();jest.spyOn(browserGuard,"_isFocusedWindowFullscreen").mockImplementation((()=>true));jest.spyOn(browserGuard,"_logFocusLost").mockImplementation((()=>"Logging focus lost"));jest.spyOn(browserGuard,"_setExamWindowStateFullscreen").mockImplementation((()=>"Setting exam window state fullscreen"));const isFocusedWindowMinimized=await browserGuard._checkIfFocusedWindowIsMinimized(currentWindow,isWindowWhitelisted);expect(chromePromise.windowsGet).toBeCalledWith(browserGuard.user.focusedWindowId);expect(browserGuard._isFocusedWindowFullscreen).toBeCalled();expect(browserGuard._logFocusLost).not.toBeCalled();expect(browserGuard._setExamWindowStateFullscreen).not.toBeCalled();expect(isFocusedWindowMinimized).toBeFalsy()}));it("will check if focused window is minimized and will log focus lost and set window state fullscreen when window is not currently fullscreen",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const currentWindow={focused:true,id:2};const isWindowWhitelisted=true;browserGuard.user.focusedWindowId=1;chromePromise.windowsGet=jest.fn();jest.spyOn(browserGuard,"_isFocusedWindowFullscreen").mockImplementation((()=>false));jest.spyOn(browserGuard,"_logFocusLost").mockImplementation((()=>"Logging focus lost"));jest.spyOn(browserGuard,"_setExamWindowStateFullscreen").mockImplementation((()=>"Setting exam window state fullscreen"));const isFocusedWindowMinimized=await browserGuard._checkIfFocusedWindowIsMinimized(currentWindow,isWindowWhitelisted);expect(chromePromise.windowsGet).toBeCalledWith(browserGuard.user.focusedWindowId);expect(browserGuard._isFocusedWindowFullscreen).toBeCalled();expect(browserGuard._logFocusLost).toBeCalled();expect(browserGuard._setExamWindowStateFullscreen).toBeCalled();expect(isFocusedWindowMinimized).toBeTruthy()}))}));describe("_checkIfRefocusRequired",(()=>{it("will not check if refocus required when window is whitelisted and focused",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const currentWindow={id:1,focused:true};const isWindowWhitelisted=true;jest.spyOn(browserGuard,"_logFocusLost").mockImplementation((()=>"Logging focus lost"));jest.spyOn(browserGuard,"_setExamWindowStateFullscreen").mockImplementation((()=>"Setting exam window fullscreen"));browserGuard._checkIfRefocusRequired(currentWindow,isWindowWhitelisted);expect(browserGuard._logFocusLost).not.toBeCalled();expect(browserGuard._setExamWindowStateFullscreen).not.toBeCalled()}));it("will handle refocus if currentWindow is whitelisted but not focused",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const currentWindow={id:1,focused:false};const isWindowWhitelisted=true;jest.spyOn(browserGuard,"_setExamWindowStateFullscreen").mockImplementation((()=>"Setting exam window fullscreen"));browserGuard._checkIfRefocusRequired(currentWindow,isWindowWhitelisted);expect(browserGuard._setExamWindowStateFullscreen).toBeCalled()}));it("will not log focus lost if user is a MacOS user",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const currentWindow={id:1,focused:true};const isWindowWhitelisted=false;jest.spyOn(browserGuard,"_logFocusLost").mockImplementation((()=>"Logging focus lost"));jest.spyOn(browserGuard,"_setExamWindowStateFullscreen").mockImplementation((()=>"Setting exam window fullscreen"));browserGuard._checkIfRefocusRequired(currentWindow,isWindowWhitelisted);expect(browserGuard._logFocusLost).not.toBeCalled();expect(browserGuard._setExamWindowStateFullscreen).toBeCalled()}));it("will not set exam window fullscreen if user is a WindowsOS user",(()=>{const browserGuard=new BrowserGuard(whitelists,{isMacUser:false,isWindowsUser:true});const currentWindow={id:1,focused:true};const isWindowWhitelisted=false;jest.spyOn(browserGuard,"_logFocusLost").mockImplementation((()=>"Logging focus lost"));jest.spyOn(browserGuard,"_setExamWindowStateFullscreen").mockImplementation((()=>"Setting exam window fullscreen"));browserGuard._checkIfRefocusRequired(currentWindow,isWindowWhitelisted);expect(browserGuard._logFocusLost).toBeCalled();expect(browserGuard._setExamWindowStateFullscreen).not.toBeCalled()}));it("will log focus lost and set exam window fullscreen if user is a ChromeOS user",(()=>{const browserGuard=new BrowserGuard(whitelists,{isMacUser:false,isWindowsUser:false});const currentWindow={id:1,focused:true};const isWindowWhitelisted=false;jest.spyOn(browserGuard,"_logFocusLost").mockImplementation((()=>"Logging focus lost"));jest.spyOn(browserGuard,"_setExamWindowStateFullscreen").mockImplementation((()=>"Setting exam window fullscreen"));browserGuard._checkIfRefocusRequired(currentWindow,isWindowWhitelisted);expect(browserGuard._logFocusLost).toBeCalled();expect(browserGuard._setExamWindowStateFullscreen).toBeCalled()}))}));describe("_logFocusLost",(()=>{it("will not send a focus lost flag if the users browser is idle",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);browserGuard.user.cameraTabId=1;browserGuard.user.examTabId=2;browserGuard.user.isBrowserIdle=true;chrome.tabs.sendMessage=jest.fn();browserGuard._translations=translations;browserGuard._logFocusLost();expect(chrome.tabs.sendMessage).not.toBeCalled()}));it("will send window_focus_lost message to camera tab and start_idle_browser_capture to exam tab",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);browserGuard.user.cameraTabId=1;browserGuard.user.examTabId=2;chrome.tabs.sendMessage=jest.fn();browserGuard._translations=translations;browserGuard._logFocusLost();expect(chrome.tabs.sendMessage).toHaveBeenNthCalledWith(1,browserGuard.user.cameraTabId,{action:"window_focus_lost"});expect(chrome.tabs.sendMessage).toHaveBeenNthCalledWith(2,browserGuard.user.examTabId,{action:"start_idle_browser_capture"});expect(browserGuard.user.isBrowserIdle).toBeTruthy()}));it("will send alert to user when focus lost",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);browserGuard.user.cameraTabId=1;browserGuard.user.examTabId=2;chrome.tabs.sendMessage=jest.fn();jest.spyOn(browserGuard,"_sendAlertToTabs").mockImplementation((()=>"Sending alert to tabs"));browserGuard._translations=translations;browserGuard._logFocusLost();expect(browserGuard._sendAlertToTabs).toBeCalled()}));it("will not send second alert to user until timeout has been exhausted",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);browserGuard.user.cameraTabId=1;browserGuard.user.examTabId=2;chrome.tabs.sendMessage=jest.fn();jest.useFakeTimers();jest.spyOn(global,"setTimeout");jest.spyOn(browserGuard,"_sendAlertToTabs").mockImplementation((()=>"Sending alert to tabs"));browserGuard._translations=translations;browserGuard._logFocusLost();browserGuard._logFocusLost();expect(browserGuard._sendAlertToTabs).toBeCalledTimes(1);jest.advanceTimersByTime(2e3);browserGuard._logFocusLost();expect(browserGuard._sendAlertToTabs).toBeCalledTimes(1);jest.advanceTimersByTime(3e3);browserGuard.user.isBrowserIdle=false;browserGuard._logFocusLost();expect(browserGuard._sendAlertToTabs).toBeCalledTimes(2)}))}));describe("_isFocusedWindowFullscreen",(()=>{it("will return false if user OS is MacOS and window state is not equal to expected browser focused state",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);browserGuard.forceFocus.windowState="normal";const window={state:"minimized"};const isFocusedWindowFullscreen=browserGuard._isFocusedWindowFullscreen(window);expect(isFocusedWindowFullscreen).toBeFalsy()}));it("will return false if user OS is MacOS and window bounds are not equal to inital user display bounds",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);browserGuard.forceFocus.windowState="normal";browserGuard.user.displayBounds=userDisplayBounds;const window={state:"normal",height:1420,left:10,top:0,width:3440};const isFocusedWindowFullscreen=browserGuard._isFocusedWindowFullscreen(window);expect(isFocusedWindowFullscreen).toBeFalsy()}));it("will return false if the browser window state is not equal to expected focused browser state",(()=>{const browserGuard=new BrowserGuard(whitelists,{isMacUser:false,isWindowsUser:true});browserGuard.forceFocus.windowState="maximized";browserGuard.user.displayBounds=userDisplayBounds;const window={state:"minimized"};const isFocusedWindowFullscreen=browserGuard._isFocusedWindowFullscreen(window);expect(isFocusedWindowFullscreen).toBeFalsy()}));it("will return true if the browser window state is equal to expected browser state and window bounds are equal to initial user display bounds",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);browserGuard.forceFocus.windowState="normal";browserGuard.user.displayBounds=userDisplayBounds;const window={state:"normal",height:1440,left:0,top:0,width:3440};const isFocusedWindowFullscreen=browserGuard._isFocusedWindowFullscreen(window);expect(isFocusedWindowFullscreen).toBeTruthy()}))}));describe("setExamWindowStateFullscreen",(()=>{it("will update the user window bounds with initial window bounds and focus the exam tab window if user is MacOS user",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);browserGuard.forceFocus.windowState="normal";browserGuard.user.displayBounds=userDisplayBounds;browserGuard.user.examTabId=10;const windowId=1;chromePromise.windowsUpdate=jest.fn();await browserGuard._setExamWindowStateFullscreen(windowId);expect(chromePromise.windowsUpdate).toBeCalledWith(windowId,{top:browserGuard.user.displayBounds.top,left:browserGuard.user.displayBounds.left,width:browserGuard.user.displayBounds.width,height:browserGuard.user.displayBounds.height,focused:true,state:browserGuard.forceFocus.windowState});expect(chrome.tabs.update).toBeCalledWith(browserGuard.user.examTabId,{active:true})}));it("will minimize the window before forcing maximized state if user is ChomeOS user",(async()=>{const browserGuard=new BrowserGuard(whitelists,{isMacUser:false,isWindowsUser:false});browserGuard.forceFocus.windowState="maximized";browserGuard.user.displayBounds=userDisplayBounds;browserGuard.user.examTabId=10;const windowId=1;chromePromise.windowsUpdate=jest.fn();await browserGuard._setExamWindowStateFullscreen(windowId);expect(chromePromise.windowsUpdate).toBeCalledWith(windowId,{focused:false,state:"minimized"})}));it("will force maximized state and focus window without explicitly setting bounds and force the exam tab window if user is WindowsOS or ChromeOS User.",(async()=>{const browserGuard=new BrowserGuard(whitelists,{isMacUser:false,isWindowsUser:false});browserGuard.forceFocus.windowState="maximized";browserGuard.user.displayBounds=userDisplayBounds;browserGuard.user.examTabId=10;const windowId=1;chromePromise.windowsUpdate=jest.fn();await browserGuard._setExamWindowStateFullscreen(windowId);expect(chromePromise.windowsUpdate).toBeCalledWith(windowId,{focused:true,state:browserGuard.forceFocus.windowState});expect(chrome.tabs.update).toBeCalledWith(browserGuard.user.examTabId,{active:true})}))}));describe("_sendMessageBrowserGuardActive",(()=>{it("will send a message to update local guard mode storage",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const senderTabId=1;chromePromise.tabsQuery=jest.fn((()=>[{id:1,url:"https://example.com"},{id:2,url:"https://example2.com"}]));jest.spyOn(browserGuard,"_updateLocalGuardModeStatus").mockImplementation((()=>"Updating local guard mode status"));await browserGuard._sendMessageBrowserGuardActive(senderTabId);expect(browserGuard._updateLocalGuardModeStatus).toBeCalled()}));it("will send a message to all tabs in a chrome instance to initialize browserguard",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const senderTabId=1;chromePromise.tabsQuery=jest.fn((()=>[{id:1,url:"https://example.com"},{id:2,url:"https://example2.com"}]));browserGuard._examWhitelist.isDefault=jest.fn();chrome.tabs.sendMessage=jest.fn();await browserGuard._sendMessageBrowserGuardActive(senderTabId);expect(chromePromise.tabsQuery).toBeCalled();expect(browserGuard._examWhitelist.isDefault).toBeCalledTimes(2);expect(chrome.tabs.sendMessage).toBeCalledWith(1,{action:"init_browser_guard"});expect(chrome.tabs.sendMessage).toBeCalledWith(2,{action:"init_browser_guard"})}));it("will send a message to the sender tab id that browser guard is active",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const senderTabId=1;chromePromise.tabsQuery=jest.fn((()=>[{id:1,url:"https://example.com"},{id:2,url:"https://example2.com"}]));chrome.tabs.sendMessage=jest.fn();await browserGuard._sendMessageBrowserGuardActive(senderTabId);expect(chrome.tabs.sendMessage).toBeCalledWith(senderTabId,{action:"browser_guard_enabled"})}))}));describe("_sendMessageBrowserGuardDisabled",(()=>{it("will send a message to update local guard mode storage",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const senderTabId=1;chromePromise.tabsQuery=jest.fn((()=>[{id:1,url:"https://example.com"},{id:2,url:"https://example2.com"}]));jest.spyOn(browserGuard,"_updateLocalGuardModeStatus").mockImplementation((()=>"Updating local guard mode status"));await browserGuard._sendMessageBrowserGuardDisabled(senderTabId);expect(browserGuard._updateLocalGuardModeStatus).toBeCalled()}));it("will send a message to all tabs that guard mode is disabled",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const senderTabId=1;chromePromise.tabsQuery=jest.fn((()=>[{id:1,url:"https://example.com"},{id:2,url:"https://example2.com"}]));chrome.tabs.sendMessage=jest.fn();await browserGuard._sendMessageBrowserGuardDisabled(senderTabId);expect(chrome.tabs.sendMessage).toBeCalledWith(1,{action:"halt_browser_guard"});expect(chrome.tabs.sendMessage).toBeCalledWith(2,{action:"halt_browser_guard"})}))}));describe("_sendAlertToTabs",(()=>{it("will send message to focus the exam tab before sending an alert",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);browserGuard.user.examTabId=2;chromePromise.tabsUpdate=jest.fn();await browserGuard._sendAlertToTabs("tacos");expect(chromePromise.tabsUpdate).toBeCalledWith(browserGuard.user.examTabId,{active:true})}));it("will send an alert to exam tab id",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);browserGuard.user.examTabId=2;chromePromise.tabsUpdate=jest.fn();chrome.tabs.sendMessage=jest.fn();const message="tacos";const timeout=3e3;await browserGuard._sendAlertToTabs(message,timeout);expect(chrome.tabs.sendMessage).toBeCalledWith(browserGuard.user.examTabId,{type:"alert",alerts:[{type:"exam",message:message,url:null,style:"",timeout:timeout}]})}))}));describe("_updateLocalGuardModeStatus",(()=>{it("will update chrome local storage to indicate browser guard has been enabled",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);browserGuard._isActive=true;chrome.storage.local.set=jest.fn();browserGuard._updateLocalGuardModeStatus();expect(chrome.storage.local.set).toBeCalledWith({guardModeStatus:1})}));it("will update chrome local storage to indicate browser guard has been disabled",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);browserGuard._isActive=false;chrome.storage.local.set=jest.fn();browserGuard._updateLocalGuardModeStatus();expect(chrome.storage.local.set).toBeCalledWith({guardModeStatus:0})}))}));describe("_isMissingWhitelistInstance",(()=>{it("will return true if any whitelist instances is missing",(()=>{const browserGuard=new BrowserGuard({exam:whitelist,window:windowWhitelist},defaultUserPlatform);const isMissingWhitelistInstance=browserGuard._isMissingWhitelistInstance();expect(isMissingWhitelistInstance).toBeTruthy()}));it("will return false if all whitelist instances are present",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const isMissingWhitelistInstance=browserGuard._isMissingWhitelistInstance();expect(isMissingWhitelistInstance).toBeFalsy()}))}));describe("_injectShortcutDetection",(()=>{it("will not inject shortcut_detection.js if browser guard is not active",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);chrome.tabs.executeScript=jest.fn();browserGuard._isActive=false;await browserGuard._injectShortcutDetection();expect(chrome.tabs.executeScript).not.toHaveBeenCalled()}));it("will not inject shortcut_detection.js if shortcut detection is not enabled within the school",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);chromePromise.storageLocalGet=jest.fn((()=>({shortcut_detection_enabled:false})));chrome.tabs.executeScript=jest.fn();browserGuard.user.examTabId=1;browserGuard._isActive=true;await browserGuard._injectShortcutDetection();expect(chromePromise.storageLocalGet).toHaveBeenCalledWith(["launch_meta","shortcut_detection_enabled"]);expect(chrome.tabs.executeScript).not.toHaveBeenCalled()}));it("will inject shortcut_detection.js if browser guard is active and shortcut detection is enabled within the school",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);chromePromise.storageLocalGet=jest.fn((()=>({shortcut_detection_enabled:true})));chrome.tabs.executeScript=jest.fn();browserGuard.user.examTabId=1;browserGuard._isActive=true;await browserGuard._injectShortcutDetection();expect(chromePromise.storageLocalGet).toHaveBeenCalledWith(["launch_meta","shortcut_detection_enabled"]);expect(chrome.tabs.executeScript).toHaveBeenCalledWith(browserGuard.user.examTabId,{allFrames:true,file:"modules/shortcut_detection.js"})}));it("will inject shortcut_detection.js for universal exams if browser guard is active and shortcut detection is enabled within the school",(async()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);chromePromise.storageLocalGet=jest.fn((()=>({launch_meta:{shortcut_detection_enabled:true}})));chrome.tabs.executeScript=jest.fn();browserGuard.user.examTabId=1;browserGuard._isActive=true;await browserGuard._injectShortcutDetection();expect(chromePromise.storageLocalGet).toHaveBeenCalledWith(["launch_meta","shortcut_detection_enabled"]);expect(chrome.tabs.executeScript).toHaveBeenCalledWith(browserGuard.user.examTabId,{allFrames:true,file:"modules/shortcut_detection.js"})}))}));describe("_stopIdleBrowserCapture",(()=>{it("will set not send the window_focus_returned message to the camera blade if the user isBrowserIdle status is false",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);browserGuard.user.cameraTabId=1;browserGuard.user.isBrowserIdle=false;chrome.tabs.sendMessage=jest.fn();browserGuard._stopIdleBrowserCapture();expect(browserGuard.user.isBrowserIdle).toBeFalsy();expect(chrome.tabs.sendMessage).not.toBeCalled()}));it("will set the user isBrowserIdle status to false and send window_focus_returned to the camera blade when receiving a stop_idle_browser_capture message",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);browserGuard.user.cameraTabId=1;browserGuard.user.isBrowserIdle=true;chrome.tabs.sendMessage=jest.fn();browserGuard._stopIdleBrowserCapture();expect(browserGuard.user.isBrowserIdle).toBeFalsy();expect(chrome.tabs.sendMessage).toBeCalledWith(browserGuard.user.cameraTabId,{action:"window_focus_returned",data:browserGuard.user.isWindowsUser})}))}));describe("_setupChromeEventListeners",(()=>{it("will add the onChromeMessage handler to the Chrome onMessage event listener",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);jest.spyOn(browserGuard,"_onChromeMessageHandler").mockImplementation((()=>"Handling chrome messages"));chrome.runtime.onMessage.addListener=jest.fn();browserGuard._setupChromeEventListeners();expect(chrome.runtime.onMessage.addListener).toHaveBeenCalledWith(browserGuard._onChromeMessageHandler)}))}));describe("_detachChromeEventListeners",(()=>{it("will remove the onChromeMessage handler from the Chrome onMessage event listener",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);jest.spyOn(browserGuard,"_onChromeMessageHandler").mockImplementation((()=>"Handling chrome messages"));chrome.runtime.onMessage.removeListener=jest.fn();browserGuard._detachChromeEventListeners();expect(chrome.runtime.onMessage.removeListener).toHaveBeenCalledWith(browserGuard._onChromeMessageHandler)}))}));describe("_onChromeMessageHandler",(()=>{it("will not call the chromeMessageListenerHandler if the request type is not `browser_guard`",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);browserGuard._chromeMessageListenerHandlers={stop_idle_browser_capture:jest.fn()};const request={message:"stop_idle_browser_capture",type:"another_type"};browserGuard._onChromeMessageHandler(request);expect(browserGuard._chromeMessageListenerHandlers.stop_idle_browser_capture).not.toBeCalled()}));it("will call _stopIdleBrowserCapture if message `stop_idle_browser_capture` is received",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const request={message:"stop_idle_browser_capture",type:"browser_guard"};jest.spyOn(browserGuard,"_stopIdleBrowserCapture").mockImplementation((()=>"Stopping idle browser capture"));browserGuard._onChromeMessageHandler(request);expect(browserGuard._stopIdleBrowserCapture).toHaveBeenCalled()}));it("will call _injectShortcutDetection if message `inject_shortcut_detection` is received",(()=>{const browserGuard=new BrowserGuard(whitelists,defaultUserPlatform);const request={message:"inject_shortcut_detection",type:"browser_guard"};jest.spyOn(browserGuard,"_injectShortcutDetection").mockImplementation((()=>"Injecting shortcut detection"));browserGuard._onChromeMessageHandler(request);expect(browserGuard._injectShortcutDetection).toHaveBeenCalled()}))}))}));